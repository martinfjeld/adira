{"version":3,"file":"static/js/796.75fe22df.chunk.js","mappings":"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","sources":["../node_modules/@sanity/client/src/csm/studioPath.ts","../node_modules/@sanity/client/src/csm/jsonPath.ts","../node_modules/@sanity/client/src/csm/resolveMapping.ts","../node_modules/@sanity/client/src/csm/walkMap.ts","../node_modules/@sanity/client/src/csm/isArray.ts","../node_modules/@sanity/client/src/csm/draftUtils.ts","../node_modules/@sanity/client/src/csm/createEditUrl.ts","../node_modules/@sanity/client/src/stega/filterDefault.ts","../node_modules/@sanity/client/src/stega/stegaEncodeSourceMap.ts","../node_modules/@sanity/client/src/stega/encodeIntoResult.ts","../node_modules/@sanity/client/src/csm/resolveEditInfo.ts"],"sourcesContent":["/** @alpha */\nexport type KeyedSegment = {_key: string}\n\n/** @alpha */\nexport type IndexTuple = [number | '', number | '']\n\n/** @alpha */\nexport type PathSegment = string | number | KeyedSegment | IndexTuple\n\n/** @alpha */\nexport type Path = PathSegment[]\n\nconst rePropName =\n  /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g\n/** @internal */\nexport const reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/\nconst reIndexTuple = /^\\d*:\\d*$/\n\n/** @internal */\nexport function isIndexSegment(segment: PathSegment): segment is number {\n  return typeof segment === 'number' || (typeof segment === 'string' && /^\\[\\d+\\]$/.test(segment))\n}\n\n/** @internal */\nexport function isKeySegment(segment: PathSegment): segment is KeyedSegment {\n  if (typeof segment === 'string') {\n    return reKeySegment.test(segment.trim())\n  }\n\n  return typeof segment === 'object' && '_key' in segment\n}\n\n/** @internal */\nexport function isIndexTuple(segment: PathSegment): segment is IndexTuple {\n  if (typeof segment === 'string' && reIndexTuple.test(segment)) {\n    return true\n  }\n\n  if (!Array.isArray(segment) || segment.length !== 2) {\n    return false\n  }\n\n  const [from, to] = segment\n  return (typeof from === 'number' || from === '') && (typeof to === 'number' || to === '')\n}\n\n/** @internal */\nexport function get<Result = unknown, Fallback = unknown>(\n  obj: unknown,\n  path: Path | string,\n  defaultVal?: Fallback,\n): Result | typeof defaultVal {\n  const select = typeof path === 'string' ? fromString(path) : path\n  if (!Array.isArray(select)) {\n    throw new Error('Path must be an array or a string')\n  }\n\n  let acc: unknown | undefined = obj\n  for (let i = 0; i < select.length; i++) {\n    const segment = select[i]\n    if (isIndexSegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc[segment]\n    }\n\n    if (isKeySegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc.find((item) => item._key === segment._key)\n    }\n\n    if (typeof segment === 'string') {\n      acc =\n        typeof acc === 'object' && acc !== null\n          ? ((acc as Record<string, unknown>)[segment] as Result)\n          : undefined\n    }\n\n    if (typeof acc === 'undefined') {\n      return defaultVal\n    }\n  }\n\n  return acc as Result\n}\n\n/** @alpha */\nexport function toString(path: Path): string {\n  if (!Array.isArray(path)) {\n    throw new Error('Path is not an array')\n  }\n\n  return path.reduce<string>((target, segment, i) => {\n    const segmentType = typeof segment\n    if (segmentType === 'number') {\n      return `${target}[${segment}]`\n    }\n\n    if (segmentType === 'string') {\n      const separator = i === 0 ? '' : '.'\n      return `${target}${separator}${segment}`\n    }\n\n    if (isKeySegment(segment) && segment._key) {\n      return `${target}[_key==\"${segment._key}\"]`\n    }\n\n    if (Array.isArray(segment)) {\n      const [from, to] = segment\n      return `${target}[${from}:${to}]`\n    }\n\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``)\n  }, '')\n}\n\n/** @alpha */\nexport function fromString(path: string): Path {\n  if (typeof path !== 'string') {\n    throw new Error('Path is not a string')\n  }\n\n  const segments = path.match(rePropName)\n  if (!segments) {\n    throw new Error('Invalid path string')\n  }\n\n  return segments.map(parsePathSegment)\n}\n\nfunction parsePathSegment(segment: string): PathSegment {\n  if (isIndexSegment(segment)) {\n    return parseIndexSegment(segment)\n  }\n\n  if (isKeySegment(segment)) {\n    return parseKeySegment(segment)\n  }\n\n  if (isIndexTuple(segment)) {\n    return parseIndexTupleSegment(segment)\n  }\n\n  return segment\n}\n\nfunction parseIndexSegment(segment: string): PathSegment {\n  return Number(segment.replace(/[^\\d]/g, ''))\n}\n\nfunction parseKeySegment(segment: string): KeyedSegment {\n  const segments = segment.match(reKeySegment)\n  return {_key: segments![1]}\n}\n\nfunction parseIndexTupleSegment(segment: string): IndexTuple {\n  const [from, to] = segment.split(':').map((seg) => (seg === '' ? seg : Number(seg)))\n  return [from, to]\n}\n","import * as studioPath from './studioPath'\nimport type {\n  ContentSourceMapParsedPath,\n  ContentSourceMapParsedPathKeyedSegment,\n  ContentSourceMapPaths,\n  Path,\n} from './types'\n\nconst ESCAPE: Record<string, string> = {\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n  \"'\": \"\\\\'\",\n  '\\\\': '\\\\\\\\',\n}\n\nconst UNESCAPE: Record<string, string> = {\n  '\\\\f': '\\f',\n  '\\\\n': '\\n',\n  '\\\\r': '\\r',\n  '\\\\t': '\\t',\n  \"\\\\'\": \"'\",\n  '\\\\\\\\': '\\\\',\n}\n\n/**\n * @internal\n */\nexport function jsonPath(path: ContentSourceMapParsedPath): ContentSourceMapPaths[number] {\n  return `$${path\n    .map((segment) => {\n      if (typeof segment === 'string') {\n        const escapedKey = segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => {\n          return ESCAPE[match]\n        })\n        return `['${escapedKey}']`\n      }\n\n      if (typeof segment === 'number') {\n        return `[${segment}]`\n      }\n\n      if (segment._key !== '') {\n        const escapedKey = segment._key.replace(/['\\\\]/g, (match) => {\n          return ESCAPE[match]\n        })\n        return `[?(@._key=='${escapedKey}')]`\n      }\n\n      return `[${segment._index}]`\n    })\n    .join('')}`\n}\n\n/**\n * @internal\n */\nexport function parseJsonPath(path: ContentSourceMapPaths[number]): ContentSourceMapParsedPath {\n  const parsed: ContentSourceMapParsedPath = []\n\n  const parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g\n  let match: RegExpExecArray | null\n\n  while ((match = parseRe.exec(path)) !== null) {\n    if (match[1] !== undefined) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => {\n        return UNESCAPE[m]\n      })\n\n      parsed.push(key)\n      continue\n    }\n\n    if (match[2] !== undefined) {\n      parsed.push(parseInt(match[2], 10))\n      continue\n    }\n\n    if (match[3] !== undefined) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => {\n        return UNESCAPE[m]\n      })\n\n      parsed.push({\n        _key,\n        _index: -1,\n      })\n      continue\n    }\n  }\n\n  return parsed\n}\n\n/**\n * @internal\n */\nexport function jsonPathToStudioPath(path: ContentSourceMapParsedPath): Path {\n  return path.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (segment._key !== '') {\n      return {_key: segment._key}\n    }\n\n    if (segment._index !== -1) {\n      return segment._index\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n\n/**\n * @internal\n */\nexport function studioPathToJsonPath(path: Path | string): ContentSourceMapParsedPath {\n  const parsedPath = typeof path === 'string' ? studioPath.fromString(path) : path\n\n  return parsedPath.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (Array.isArray(segment)) {\n      throw new Error(`IndexTuple segments aren't supported:${JSON.stringify(segment)}`)\n    }\n\n    if (isContentSourceMapParsedPathKeyedSegment(segment)) {\n      return segment\n    }\n\n    if (segment._key) {\n      return {_key: segment._key, _index: -1}\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n\nfunction isContentSourceMapParsedPathKeyedSegment(\n  segment: studioPath.PathSegment | ContentSourceMapParsedPath[number],\n): segment is ContentSourceMapParsedPathKeyedSegment {\n  return typeof segment === 'object' && '_key' in segment && '_index' in segment\n}\n\n/**\n * @internal\n */\nexport function jsonPathToMappingPath(path: ContentSourceMapParsedPath): (string | number)[] {\n  return path.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (segment._index !== -1) {\n      return segment._index\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n","import {jsonPath, jsonPathToMappingPath} from './jsonPath'\nimport type {ContentSourceMap, ContentSourceMapMapping, ContentSourceMapParsedPath} from './types'\n\n/**\n * @internal\n */\nexport function resolveMapping(\n  resultPath: ContentSourceMapParsedPath,\n  csm?: ContentSourceMap,\n):\n  | {\n      mapping: ContentSourceMapMapping\n      matchedPath: string\n      pathSuffix: string\n    }\n  | undefined {\n  if (!csm?.mappings) {\n    return undefined\n  }\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath))\n\n  if (csm.mappings[resultMappingPath] !== undefined) {\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: '',\n    }\n  }\n\n  const mappings = Object.entries(csm.mappings)\n    .filter(([key]) => resultMappingPath.startsWith(key))\n    .sort(([key1], [key2]) => key2.length - key1.length)\n\n  if (mappings.length == 0) {\n    return undefined\n  }\n\n  const [matchedPath, mapping] = mappings[0]\n  const pathSuffix = resultMappingPath.substring(matchedPath.length)\n  return {mapping, matchedPath, pathSuffix}\n}\n","import {isRecord} from '../util/isRecord'\nimport {isArray} from './isArray'\nimport type {ContentSourceMapParsedPath, WalkMapFn} from './types'\n\n/**\n * generic way to walk a nested object or array and apply a mapping function to each value\n * @internal\n */\nexport function walkMap(\n  value: unknown,\n  mappingFn: WalkMapFn,\n  path: ContentSourceMapParsedPath = [],\n): unknown {\n  if (isArray(value)) {\n    return value.map((v, idx) => {\n      if (isRecord(v)) {\n        const _key = v['_key']\n        if (typeof _key === 'string') {\n          return walkMap(v, mappingFn, path.concat({_key, _index: idx}))\n        }\n      }\n\n      return walkMap(v, mappingFn, path.concat(idx))\n    })\n  }\n\n  if (isRecord(value)) {\n    // Handle Portable Text in a faster way\n    if (value._type === 'block' || value._type === 'span') {\n      const result = {...value}\n      if (value._type === 'block') {\n        result.children = walkMap(value.children, mappingFn, path.concat('children'))\n      } else if (value._type === 'span') {\n        result.text = walkMap(value.text, mappingFn, path.concat('text'))\n      }\n      return result\n    }\n\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))]),\n    )\n  }\n\n  return mappingFn(value, path)\n}\n","/** @internal */\nexport function isArray(value: unknown): value is Array<unknown> {\n  return value !== null && Array.isArray(value)\n}\n","// nominal/opaque type hack\ntype Opaque<T, K> = T & {__opaqueId__: K}\n\n/** @internal */\nexport type DraftId = Opaque<string, 'draftId'>\n\n/** @internal */\nexport type PublishedId = Opaque<string, 'publishedId'>\n\n/** @internal */\nexport const DRAFTS_FOLDER = 'drafts'\n\n/** @internal */\nexport const VERSION_FOLDER = 'versions'\n\nconst PATH_SEPARATOR = '.'\nconst DRAFTS_PREFIX = `${DRAFTS_FOLDER}${PATH_SEPARATOR}`\nconst VERSION_PREFIX = `${VERSION_FOLDER}${PATH_SEPARATOR}`\n\n/** @internal */\nexport function isDraftId(id: string): id is DraftId {\n  return id.startsWith(DRAFTS_PREFIX)\n}\n\n/** @internal */\nexport function isVersionId(id: string): boolean {\n  return id.startsWith(VERSION_PREFIX)\n}\n\n/** @internal */\nexport function isPublishedId(id: string): id is PublishedId {\n  return !isDraftId(id) && !isVersionId(id)\n}\n\n/** @internal */\nexport function getDraftId(id: string): DraftId {\n  if (isVersionId(id)) {\n    const publishedId = getPublishedId(id)\n    return (DRAFTS_PREFIX + publishedId) as DraftId\n  }\n\n  return isDraftId(id) ? id : ((DRAFTS_PREFIX + id) as DraftId)\n}\n\n/**  @internal */\nexport function getVersionId(id: string, version: string): string {\n  if (version === 'drafts' || version === 'published') {\n    throw new Error('Version can not be \"published\" or \"drafts\"')\n  }\n\n  return `${VERSION_PREFIX}${version}${PATH_SEPARATOR}${getPublishedId(id)}`\n}\n\n/**\n *  @internal\n *  Given an id, returns the versionId if it exists.\n *  e.g. `versions.summer-drop.foo` = `summer-drop`\n *  e.g. `drafts.foo` = `undefined`\n *  e.g. `foo` = `undefined`\n */\nexport function getVersionFromId(id: string): string | undefined {\n  if (!isVersionId(id)) return undefined\n  // eslint-disable-next-line unused-imports/no-unused-vars\n  const [_versionPrefix, versionId, ..._publishedId] = id.split(PATH_SEPARATOR)\n\n  return versionId\n}\n\n/** @internal */\nexport function getPublishedId(id: string): PublishedId {\n  if (isVersionId(id)) {\n    // make sure to only remove the versions prefix and the bundle name\n    return id.split(PATH_SEPARATOR).slice(2).join(PATH_SEPARATOR) as PublishedId as PublishedId\n  }\n\n  if (isDraftId(id)) {\n    return id.slice(DRAFTS_PREFIX.length) as PublishedId\n  }\n\n  return id as PublishedId\n}\n","import {getPublishedId, getVersionFromId, isPublishedId, isVersionId} from './draftUtils'\nimport {jsonPathToStudioPath} from './jsonPath'\nimport * as studioPath from './studioPath'\nimport type {CreateEditUrlOptions, EditIntentUrl, StudioBaseUrl} from './types'\n\n/** @internal */\nexport function createEditUrl(options: CreateEditUrlOptions): `${StudioBaseUrl}${EditIntentUrl}` {\n  const {\n    baseUrl,\n    workspace: _workspace = 'default',\n    tool: _tool = 'default',\n    id: _id,\n    type,\n    path,\n    projectId,\n    dataset,\n  } = options\n\n  if (!baseUrl) {\n    throw new Error('baseUrl is required')\n  }\n  if (!path) {\n    throw new Error('path is required')\n  }\n  if (!_id) {\n    throw new Error('id is required')\n  }\n  if (baseUrl !== '/' && baseUrl.endsWith('/')) {\n    throw new Error('baseUrl must not end with a slash')\n  }\n\n  const workspace = _workspace === 'default' ? undefined : _workspace\n  const tool = _tool === 'default' ? undefined : _tool\n  const id = getPublishedId(_id)\n  const stringifiedPath = Array.isArray(path)\n    ? studioPath.toString(jsonPathToStudioPath(path))\n    : path\n\n  // eslint-disable-next-line no-warning-comments\n  // @TODO Using searchParams as a temporary workaround until `@sanity/overlays` can decode state from the path reliably\n  const searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath,\n  })\n  if (workspace) {\n    searchParams.set('workspace', workspace)\n  }\n  if (tool) {\n    searchParams.set('tool', tool)\n  }\n  if (projectId) {\n    searchParams.set('projectId', projectId)\n  }\n  if (dataset) {\n    searchParams.set('dataset', dataset)\n  }\n  if (isPublishedId(_id)) {\n    searchParams.set('perspective', 'published')\n  } else if (isVersionId(_id)) {\n    const versionId = getVersionFromId(_id)!\n    searchParams.set('perspective', versionId)\n  }\n\n  const segments = [baseUrl === '/' ? '' : baseUrl]\n  if (workspace) {\n    segments.push(workspace)\n  }\n  const routerParams = [\n    'mode=presentation',\n    `id=${id}`,\n    `type=${type}`,\n    `path=${encodeURIComponent(stringifiedPath)}`,\n  ]\n  if (tool) {\n    routerParams.push(`tool=${tool}`)\n  }\n  segments.push('intent', 'edit', `${routerParams.join(';')}?${searchParams}`)\n  return segments.join('/') as unknown as `${StudioBaseUrl}${EditIntentUrl}`\n}\n","import type {ContentSourceMapParsedPath, FilterDefault} from './types'\n\nexport const filterDefault: FilterDefault = ({sourcePath, resultPath, value}) => {\n  // Skips encoding on URL or Date strings, similar to the `skip: 'auto'` parameter in vercelStegaCombine()\n  if (isValidDate(value) || isValidURL(value)) {\n    return false\n  }\n\n  const endPath = sourcePath.at(-1)\n  // Never encode slugs\n  if (sourcePath.at(-2) === 'slug' && endPath === 'current') {\n    return false\n  }\n\n  // Skip underscored keys, and strings that end with `Id`, needs better heuristics but it works for now\n  if (typeof endPath === 'string' && (endPath.startsWith('_') || endPath.endsWith('Id'))) {\n    return false\n  }\n\n  // Don't encode into anything that is suggested it'll render for SEO in meta tags\n  if (\n    sourcePath.some(\n      (path) => path === 'meta' || path === 'metadata' || path === 'openGraph' || path === 'seo',\n    )\n  ) {\n    return false\n  }\n\n  // If the sourcePath or resultPath contains something that sounds like a type, like iconType, we skip encoding, as it's most\n  // of the time used for logic that breaks if it contains stega characters\n  if (hasTypeLike(sourcePath) || hasTypeLike(resultPath)) {\n    return false\n  }\n\n  // Finally, we ignore a bunch of paths that are typically used for page building\n  if (typeof endPath === 'string' && denylist.has(endPath)) {\n    return false\n  }\n\n  return true\n}\n\nconst denylist = new Set([\n  'color',\n  'colour',\n  'currency',\n  'email',\n  'format',\n  'gid',\n  'hex',\n  'href',\n  'hsl',\n  'hsla',\n  'icon',\n  'id',\n  'index',\n  'key',\n  'language',\n  'layout',\n  'link',\n  'linkAction',\n  'locale',\n  'lqip',\n  'page',\n  'path',\n  'ref',\n  'rgb',\n  'rgba',\n  'route',\n  'secret',\n  'slug',\n  'status',\n  'tag',\n  'template',\n  'theme',\n  'type',\n  'textTheme',\n  'unit',\n  'url',\n  'username',\n  'variant',\n  'website',\n])\n\nfunction isValidDate(dateString: string) {\n  return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? Boolean(Date.parse(dateString)) : false\n}\n\nconst allowedProtocols = new Set([\n  'app:',\n  'data:',\n  'discord:',\n  'file:',\n  'ftp:',\n  'ftps:',\n  'geo:',\n  'http:',\n  'https:',\n  'imap:',\n  'javascript:',\n  'magnet:',\n  'mailto:',\n  'maps:',\n  'ms-excel:',\n  'ms-powerpoint:',\n  'ms-word:',\n  'slack:',\n  'sms:',\n  'spotify:',\n  'steam:',\n  'teams:',\n  'tel:',\n  'vscode:',\n  'zoom:',\n])\n\nfunction isValidURL(url: string) {\n  try {\n    const {protocol} = new URL(url, url.startsWith('/') ? 'https://acme.com' : undefined)\n    return allowedProtocols.has(protocol) || protocol.startsWith('web+')\n  } catch {\n    return false\n  }\n}\n\nfunction hasTypeLike(path: ContentSourceMapParsedPath): boolean {\n  return path.some((segment) => typeof segment === 'string' && segment.match(/type/i) !== null)\n}\n","import {vercelStegaCombine} from '@vercel/stega'\n\nimport {createEditUrl} from '../csm/createEditUrl'\nimport {jsonPathToStudioPath} from '../csm/jsonPath'\nimport {resolveStudioBaseRoute} from '../csm/resolveEditInfo'\nimport {reKeySegment, toString as studioPathToString} from '../csm/studioPath'\nimport {encodeIntoResult} from './encodeIntoResult'\nimport {filterDefault} from './filterDefault'\nimport {\n  type ContentSourceMap,\n  type ContentSourceMapParsedPath,\n  type InitializedStegaConfig,\n} from './types'\n\nconst TRUNCATE_LENGTH = 20\n\n/**\n * Uses `@vercel/stega` to embed edit info JSON into strings in your query result.\n * The JSON payloads are added using invisible characters so they don't show up visually.\n * The edit info is generated from the Content Source Map (CSM) that is returned from Sanity for the query.\n * @public\n */\nexport function stegaEncodeSourceMap<Result = unknown>(\n  result: Result,\n  resultSourceMap: ContentSourceMap | undefined,\n  config: InitializedStegaConfig,\n): Result {\n  const {filter, logger, enabled} = config\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\"\n    logger?.error?.(`[@sanity/client]: ${msg}`, {result, resultSourceMap, config})\n    throw new TypeError(msg)\n  }\n\n  if (!resultSourceMap) {\n    logger?.error?.('[@sanity/client]: Missing Content Source Map from response body', {\n      result,\n      resultSourceMap,\n      config,\n    })\n    return result\n  }\n\n  if (!config.studioUrl) {\n    const msg = 'config.studioUrl must be defined'\n    logger?.error?.(`[@sanity/client]: ${msg}`, {result, resultSourceMap, config})\n    throw new TypeError(msg)\n  }\n\n  const report: Record<'encoded' | 'skipped', {path: string; length: number; value: string}[]> = {\n    encoded: [],\n    skipped: [],\n  }\n\n  const resultWithStega = encodeIntoResult(\n    result,\n    resultSourceMap,\n    ({sourcePath, sourceDocument, resultPath, value}) => {\n      // Allow userland to control when to opt-out of encoding\n      if (\n        (typeof filter === 'function'\n          ? filter({sourcePath, resultPath, filterDefault, sourceDocument, value})\n          : filterDefault({sourcePath, resultPath, filterDefault, sourceDocument, value})) === false\n      ) {\n        if (logger) {\n          report.skipped.push({\n            path: prettyPathForLogging(sourcePath),\n            value: `${value.slice(0, TRUNCATE_LENGTH)}${\n              value.length > TRUNCATE_LENGTH ? '...' : ''\n            }`,\n            length: value.length,\n          })\n        }\n        return value\n      }\n\n      if (logger) {\n        report.encoded.push({\n          path: prettyPathForLogging(sourcePath),\n          value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? '...' : ''}`,\n          length: value.length,\n        })\n      }\n\n      const {baseUrl, workspace, tool} = resolveStudioBaseRoute(\n        typeof config.studioUrl === 'function'\n          ? config.studioUrl(sourceDocument)\n          : config.studioUrl!,\n      )\n      if (!baseUrl) return value\n      const {_id: id, _type: type, _projectId: projectId, _dataset: dataset} = sourceDocument\n\n      return vercelStegaCombine(\n        value,\n        {\n          origin: 'sanity.io',\n          href: createEditUrl({\n            baseUrl,\n            workspace,\n            tool,\n            id,\n            type,\n            path: sourcePath,\n            ...(!config.omitCrossDatasetReferenceData && {dataset, projectId}),\n          }),\n        },\n        // We use custom logic to determine if we should skip encoding\n        false,\n      )\n    },\n  )\n\n  if (logger) {\n    const isSkipping = report.skipped.length\n    const isEncoding = report.encoded.length\n    if (isSkipping || isEncoding) {\n      ;(logger?.groupCollapsed || logger.log)?.('[@sanity/client]: Encoding source map into result')\n      logger.log?.(\n        `[@sanity/client]: Paths encoded: ${report.encoded.length}, skipped: ${report.skipped.length}`,\n      )\n    }\n    if (report.encoded.length > 0) {\n      logger?.log?.(`[@sanity/client]: Table of encoded paths`)\n      ;(logger?.table || logger.log)?.(report.encoded)\n    }\n    if (report.skipped.length > 0) {\n      const skipped = new Set<string>()\n      for (const {path} of report.skipped) {\n        skipped.add(path.replace(reKeySegment, '0').replace(/\\[\\d+\\]/g, '[]'))\n      }\n      logger?.log?.(`[@sanity/client]: List of skipped paths`, [...skipped.values()])\n    }\n\n    if (isSkipping || isEncoding) {\n      logger?.groupEnd?.()\n    }\n  }\n\n  return resultWithStega\n}\n\nfunction prettyPathForLogging(path: ContentSourceMapParsedPath): string {\n  return studioPathToString(jsonPathToStudioPath(path))\n}\n","import type {ContentSourceMap} from '@sanity/client/csm'\n\nimport {parseJsonPath} from '../csm/jsonPath'\nimport {resolveMapping} from '../csm/resolveMapping'\nimport {walkMap} from '../csm/walkMap'\nimport type {Encoder} from './types'\n\n/**\n * @internal\n */\nexport function encodeIntoResult<Result>(\n  result: Result,\n  csm: ContentSourceMap,\n  encoder: Encoder,\n): Result {\n  return walkMap(result, (value, path) => {\n    // Only map strings, we could extend this in the future to support other types like integers...\n    if (typeof value !== 'string') {\n      return value\n    }\n\n    const resolveMappingResult = resolveMapping(path, csm)\n    if (!resolveMappingResult) {\n      return value\n    }\n\n    const {mapping, matchedPath} = resolveMappingResult\n    if (mapping.type !== 'value') {\n      return value\n    }\n\n    if (mapping.source.type !== 'documentValue') {\n      return value\n    }\n\n    const sourceDocument = csm.documents[mapping.source.document!]\n    const sourcePath = csm.paths[mapping.source.path]\n\n    const matchPathSegments = parseJsonPath(matchedPath)\n    const sourcePathSegments = parseJsonPath(sourcePath)\n    const fullSourceSegments = sourcePathSegments.concat(path.slice(matchPathSegments.length))\n\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value,\n    })\n  }) as Result\n}\n","import {parseJsonPath} from './jsonPath'\nimport {resolveMapping} from './resolveMapping'\nimport type {\n  CreateEditUrlOptions,\n  ResolveEditInfoOptions,\n  StudioBaseRoute,\n  StudioBaseUrl,\n  StudioUrl,\n} from './types'\n\n/** @internal */\nexport function resolveEditInfo(options: ResolveEditInfoOptions): CreateEditUrlOptions | undefined {\n  const {resultSourceMap: csm, resultPath} = options\n  const {mapping, pathSuffix} = resolveMapping(resultPath, csm) || {}\n\n  if (!mapping) {\n    // console.warn('no mapping for path', { path: resultPath, sourceMap: csm })\n    return undefined\n  }\n\n  if (mapping.source.type === 'literal') {\n    return undefined\n  }\n\n  if (mapping.source.type === 'unknown') {\n    return undefined\n  }\n\n  const sourceDoc = csm.documents[mapping.source.document]\n  const sourcePath = csm.paths[mapping.source.path]\n\n  if (sourceDoc && sourcePath) {\n    const {baseUrl, workspace, tool} = resolveStudioBaseRoute(\n      typeof options.studioUrl === 'function' ? options.studioUrl(sourceDoc) : options.studioUrl,\n    )\n    if (!baseUrl) return undefined\n    const {_id, _type, _projectId, _dataset} = sourceDoc\n    return {\n      baseUrl,\n      workspace,\n      tool,\n      id: _id,\n      type: _type,\n      path: parseJsonPath(sourcePath + pathSuffix),\n      projectId: _projectId,\n      dataset: _dataset,\n    } satisfies CreateEditUrlOptions\n  }\n\n  return undefined\n}\n\n/** @internal */\nexport function resolveStudioBaseRoute(studioUrl: StudioUrl): StudioBaseRoute {\n  let baseUrl: StudioBaseUrl = typeof studioUrl === 'string' ? studioUrl : studioUrl.baseUrl\n  if (baseUrl !== '/') {\n    baseUrl = baseUrl.replace(/\\/$/, '')\n  }\n  if (typeof studioUrl === 'string') {\n    return {baseUrl}\n  }\n  return {...studioUrl, baseUrl}\n}\n"],"names":["reKeySegment","toString","path","Array","isArray","Error","reduce","target","segment","i","segmentType","concat","test","trim","isKeySegment","_key","from","to","JSON","stringify","ESCAPE","UNESCAPE","parseJsonPath","parsed","parseRe","match","exec","key","replace","m","push","_index","parseInt","jsonPathToStudioPath","map","resolveMapping","resultPath","csm","mappings","resultMappingPath","join","jsonPath","mapping","matchedPath","pathSuffix","Object","entries","filter","_ref","startsWith","sort","_ref2","_ref3","key1","key2","length","substring","walkMap","value","mappingFn","arguments","undefined","v","idx","isRecord","_type","result","_objectSpread","children","text","fromEntries","_ref4","k","PATH_SEPARATOR","DRAFTS_PREFIX","VERSION_PREFIX","isDraftId","id","isVersionId","createEditUrl","options","baseUrl","workspace","_workspace","tool","_tool","_id","type","projectId","dataset","endsWith","split","slice","getPublishedId","stringifiedPath","searchParams","URLSearchParams","set","isPublishedId","versionId","_versionPrefix","_publishedId","getVersionFromId","segments","routerParams","encodeURIComponent","filterDefault","_ref5","sourcePath","dateString","Date","parse","url","protocol","URL","allowedProtocols","has","_unused","isValidURL","endPath","at","some","hasTypeLike","denylist","Set","prettyPathForLogging","resultSourceMap","config","_logger$error2","logger","enabled","_logger$error","msg","error","call","TypeError","studioUrl","_logger$error3","report","encoded","skipped","resultWithStega","encoder","resolveMappingResult","source","sourceDocument","documents","document","paths","matchPathSegments","fullSourceSegments","encodeIntoResult","_ref6","resolveStudioBaseRoute","_projectId","_dataset","C","origin","href","omitCrossDatasetReferenceData","_ref7","_logger$log","_logger$log2","_ref8","_logger$groupEnd","isSkipping","isEncoding","groupCollapsed","log","table","_logger$log3","add","values","groupEnd"],"sourceRoot":""}